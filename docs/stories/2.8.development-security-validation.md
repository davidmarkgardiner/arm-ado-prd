# Story 2.8: Development Environment Security Validation

<!-- Powered by BMADâ„¢ Core -->

## Status
Draft

## Story
**As a** Security Engineer,
**I want** to validate development environment security,
**So that** security standards are maintained.

## Acceptance Criteria
1. Security scan completed with no high-severity issues
2. Penetration testing conducted
3. Compliance validation passed
4. Security policies enforced and monitored
5. Incident response procedures tested

## Tasks / Subtasks
- [ ] Conduct comprehensive security scanning (AC: 1)
  - [ ] Run vulnerability assessment on all cluster components
  - [ ] Perform container image security scanning
  - [ ] Execute network security assessment
  - [ ] Scan for misconfigurations and policy violations
  - [ ] Generate comprehensive security report
- [ ] Perform penetration testing on development environment (AC: 2)
  - [ ] Execute external penetration testing scenarios
  - [ ] Perform internal network penetration testing
  - [ ] Test application-level security controls
  - [ ] Assess privilege escalation vulnerabilities
  - [ ] Document penetration testing findings
- [ ] Validate compliance with security standards (AC: 3)
  - [ ] Execute CIS Kubernetes benchmark assessment
  - [ ] Validate SOC 2 compliance controls
  - [ ] Check NIST 800-53 control implementation
  - [ ] Verify data protection and privacy controls
  - [ ] Generate compliance assessment report
- [ ] Test security policy enforcement (AC: 4)
  - [ ] Validate Pod Security Standards enforcement
  - [ ] Test OPA Gatekeeper policy compliance
  - [ ] Verify network policy effectiveness
  - [ ] Check RBAC and access control enforcement
  - [ ] Test workload identity security controls
- [ ] Execute incident response simulation (AC: 5)
  - [ ] Simulate security incident scenarios
  - [ ] Test incident detection and alerting
  - [ ] Validate incident response procedures
  - [ ] Test forensic investigation capabilities
  - [ ] Document incident response effectiveness
- [ ] Document security validation results (AC: 1, 2, 3, 4, 5)
  - [ ] Compile comprehensive security assessment report
  - [ ] Document all security findings and remediations
  - [ ] Create security posture dashboard
  - [ ] Update security documentation and procedures
  - [ ] Present findings to security review board

## Dev Notes

### Previous Story Dependencies
This story builds on:
- Story 2.7 (Environment Monitoring): Security monitoring must be operational
- All previous Epic 2 stories: Complete development environment must be operational and optimized
- Epic 1 security foundation stories: Security baseline must be established

### Security Validation Framework
**Comprehensive Security Assessment Scope** [Source: architecture.md#security-architecture]:
```yaml
security_validation_scope:
  infrastructure_security:
    - "Kubernetes cluster hardening"
    - "Network security controls"
    - "Identity and access management"
    - "Encryption and data protection"

  application_security:
    - "Container image vulnerabilities"
    - "Application-level security controls"
    - "API security and authentication"
    - "Data validation and sanitization"

  operational_security:
    - "Security monitoring and logging"
    - "Incident response capabilities"
    - "Backup and disaster recovery"
    - "Security policy enforcement"

  compliance_requirements:
    - "SOC 2 Type II controls"
    - "CIS Kubernetes Benchmark"
    - "NIST Cybersecurity Framework"
    - "Industry-specific regulations"
```

### Vulnerability Assessment and Scanning
**Comprehensive Security Scanning Configuration**:
```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: security-assessment
  namespace: security
spec:
  template:
    spec:
      containers:
      - name: kube-bench
        image: aquasec/kube-bench:latest
        command: ["kube-bench"]
        args: ["--config-dir", "/opt/kube-bench/cfg/", "--config", "aks-1.0"]
        volumeMounts:
        - name: var-lib-etcd
          mountPath: /var/lib/etcd
          readOnly: true
        - name: var-lib-kubelet
          mountPath: /var/lib/kubelet
          readOnly: true
        - name: etc-systemd
          mountPath: /etc/systemd
          readOnly: true
        - name: etc-kubernetes
          mountPath: /etc/kubernetes
          readOnly: true

      - name: kube-hunter
        image: aquasec/kube-hunter:latest
        command: ["kube-hunter"]
        args: ["--pod", "--quick"]

      - name: falco-security-scan
        image: falcosecurity/falco:latest
        command: ["/usr/bin/falco"]
        args: ["-r", "/etc/falco/falco_rules.yaml", "--validate-rules-file"]

      volumes:
      - name: var-lib-etcd
        hostPath:
          path: /var/lib/etcd
      - name: var-lib-kubelet
        hostPath:
          path: /var/lib/kubelet
      - name: etc-systemd
        hostPath:
          path: /etc/systemd
      - name: etc-kubernetes
        hostPath:
          path: /etc/kubernetes
      restartPolicy: Never

---
# Container image scanning with Trivy
apiVersion: batch/v1
kind: CronJob
metadata:
  name: container-image-scan
  namespace: security
spec:
  schedule: "0 2 * * *"  # Daily at 2 AM
  jobTemplate:
    spec:
      template:
        spec:
          containers:
          - name: trivy-scanner
            image: aquasec/trivy:latest
            command:
            - /bin/sh
            - -c
            - |
              # Scan all images in development namespace
              for image in $(kubectl get pods -n applications -o jsonpath='{.items[*].spec.containers[*].image}' | tr ' ' '\n' | sort -u); do
                echo "Scanning image: $image"
                trivy image --format json --output "/reports/$(echo $image | tr '/' '_' | tr ':' '_').json" $image
              done
            volumeMounts:
            - name: reports
              mountPath: /reports
          volumes:
          - name: reports
            persistentVolumeClaim:
              claimName: security-reports-pvc
          restartPolicy: OnFailure
```

### Penetration Testing Framework
**Automated Penetration Testing Suite**:
```bash
#!/bin/bash
# penetration-test-suite.sh

echo "Starting development environment penetration testing..."

# Configuration
CLUSTER_NAME="dev-workloads-aks-001"
NAMESPACE="applications"
TARGET_APPS=("dev-frontend" "dev-backend-api")

# 1. External Network Penetration Testing
echo "=== External Network Penetration Testing ==="

# Test external load balancer security
EXTERNAL_IP=$(kubectl get svc nginx-ingress-controller -n ingress-nginx -o jsonpath='{.status.loadBalancer.ingress[0].ip}')

if [ ! -z "$EXTERNAL_IP" ]; then
  echo "Testing external IP: $EXTERNAL_IP"

  # Port scanning
  nmap -sS -O -p 1-65535 $EXTERNAL_IP > /reports/external-portscan.txt

  # HTTP security testing
  nikto -h http://$EXTERNAL_IP -output /reports/nikto-results.txt

  # SSL/TLS testing
  sslscan --show-certificate --show-client-cas $EXTERNAL_IP:443 > /reports/ssl-scan.txt
fi

# 2. Internal Network Penetration Testing
echo "=== Internal Network Penetration Testing ==="

# Deploy internal penetration testing pod
kubectl apply -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: internal-pentest
  namespace: security
spec:
  containers:
  - name: kali
    image: kalilinux/kali-rolling:latest
    command: ["/bin/bash", "-c", "sleep 3600"]
    securityContext:
      capabilities:
        add: ["NET_RAW", "NET_ADMIN"]
  restartPolicy: Never
EOF

# Wait for pod to start
kubectl wait --for=condition=Ready pod/internal-pentest -n security --timeout=120s

# Execute internal network tests
kubectl exec -n security internal-pentest -- bash -c "
  apt-get update && apt-get install -y nmap nikto dirb

  # Internal network discovery
  nmap -sn 10.240.0.0/16 > /tmp/network-discovery.txt

  # Service discovery
  nmap -sS -p 1-1000 10.240.1.1-254 > /tmp/internal-portscan.txt

  # Test internal services
  for service in dev-frontend dev-backend-api; do
    echo \"Testing \$service...\"
    curl -I \$service.applications.svc.cluster.local
    nikto -h http://\$service.applications.svc.cluster.local
  done
"

# Copy results
kubectl cp security/internal-pentest:/tmp/network-discovery.txt /reports/
kubectl cp security/internal-pentest:/tmp/internal-portscan.txt /reports/

# 3. Application-Level Security Testing
echo "=== Application-Level Security Testing ==="

for app in "${TARGET_APPS[@]}"; do
  echo "Testing application: $app"

  # OWASP ZAP scanning
  kubectl run zap-scan-$app --image=owasp/zap2docker-stable --rm -it --restart=Never -- \
    zap-baseline.py -t http://$app.applications.svc.cluster.local -J /reports/zap-$app.json
done

# 4. Kubernetes Security Testing
echo "=== Kubernetes Security Testing ==="

# Test RBAC bypasses
kubectl auth can-i --list --as=system:anonymous > /reports/anonymous-permissions.txt

# Test service account token access
kubectl get serviceaccounts --all-namespaces -o yaml > /reports/service-accounts.yaml

# Test secret access
kubectl get secrets --all-namespaces > /reports/secrets-list.txt

# 5. Privilege Escalation Testing
echo "=== Privilege Escalation Testing ==="

# Test container breakout scenarios
kubectl apply -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: privilege-escalation-test
  namespace: security
spec:
  containers:
  - name: test
    image: ubuntu:latest
    command: ["/bin/bash", "-c"]
    args:
    - |
      # Test various privilege escalation vectors
      echo "Testing privilege escalation..."

      # Test host filesystem access
      ls -la /host 2>/dev/null || echo "Host filesystem not accessible"

      # Test docker socket access
      ls -la /var/run/docker.sock 2>/dev/null || echo "Docker socket not accessible"

      # Test privileged operations
      mount 2>/dev/null || echo "Mount operation restricted"

      sleep 300
    securityContext:
      runAsNonRoot: true
      runAsUser: 1000
      allowPrivilegeEscalation: false
      readOnlyRootFilesystem: true
      capabilities:
        drop: ["ALL"]
    volumeMounts:
    - name: host-root
      mountPath: /host
      readOnly: true
  volumes:
  - name: host-root
    hostPath:
      path: /
  restartPolicy: Never
EOF

echo "Penetration testing completed. Results stored in /reports/"
```

### Compliance Validation
**CIS Kubernetes Benchmark Assessment**:
```yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: cis-benchmark-config
  namespace: security
data:
  cis-assessment.yaml: |
    # CIS Kubernetes Benchmark Controls
    controls:
      master_node:
        1.1.1: "API server pod specification file permissions"
        1.1.2: "API server pod specification file ownership"
        1.1.3: "Controller manager pod specification file permissions"
        1.1.4: "Controller manager pod specification file ownership"
        1.1.5: "Scheduler pod specification file permissions"
        1.1.6: "Scheduler pod specification file ownership"
        1.1.7: "etcd pod specification file permissions"
        1.1.8: "etcd pod specification file ownership"

      api_server:
        1.2.1: "anonymous-auth argument"
        1.2.2: "basic-auth-file argument"
        1.2.3: "token-auth-file argument"
        1.2.4: "kubelet-https argument"
        1.2.5: "kubelet-client-certificate and kubelet-client-key arguments"

      worker_node:
        4.1.1: "kubelet service file permissions"
        4.1.2: "kubelet service file ownership"
        4.1.3: "proxy kubeconfig file permissions"
        4.1.4: "proxy kubeconfig file ownership"

      policies:
        5.1.1: "RBAC is used for authorization"
        5.1.2: "Minimize access to secrets"
        5.1.3: "Minimize wildcard use in Roles and ClusterRoles"
        5.1.4: "Minimize access to create pods"

---
# SOC 2 Compliance validation
apiVersion: batch/v1
kind: Job
metadata:
  name: soc2-compliance-check
  namespace: security
spec:
  template:
    spec:
      containers:
      - name: compliance-checker
        image: company/compliance-checker:latest
        command: ["/bin/bash", "-c"]
        args:
        - |
          echo "SOC 2 Compliance Assessment for Development Environment"

          # CC6.1 - Logical and physical access controls
          echo "Checking access controls..."
          kubectl get rbac.authorization.k8s.io/v1/clusterroles --all-namespaces
          kubectl get rbac.authorization.k8s.io/v1/rolebindings --all-namespaces

          # CC6.2 - Network controls
          echo "Checking network policies..."
          kubectl get networkpolicies --all-namespaces

          # CC6.3 - Encryption controls
          echo "Checking encryption at rest..."
          kubectl get storageclass -o yaml | grep -i encrypt

          # CC7.1 - System monitoring
          echo "Checking monitoring configuration..."
          kubectl get servicemonitors.monitoring.coreos.com --all-namespaces
          kubectl get prometheusrules.monitoring.coreos.com --all-namespaces

          # CC8.1 - Change management
          echo "Checking GitOps configuration..."
          kubectl get gitrepositories.source.toolkit.fluxcd.io --all-namespaces
          kubectl get kustomizations.kustomize.toolkit.fluxcd.io --all-namespaces

          echo "SOC 2 compliance check completed"
        volumeMounts:
        - name: reports
          mountPath: /reports
      volumes:
      - name: reports
        persistentVolumeClaim:
          claimName: compliance-reports-pvc
      restartPolicy: Never
```

### Security Policy Enforcement Testing
**Policy Enforcement Validation Framework**:
```bash
#!/bin/bash
# security-policy-test.sh

echo "Testing security policy enforcement..."

# 1. Test Pod Security Standards
echo "=== Testing Pod Security Standards ==="

# Test privileged container rejection
kubectl apply -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: privileged-test
  namespace: applications
spec:
  containers:
  - name: test
    image: nginx
    securityContext:
      privileged: true
EOF

if kubectl get pod privileged-test -n applications 2>/dev/null; then
  echo "FAIL: Privileged pod was not rejected"
else
  echo "PASS: Privileged pod was correctly rejected"
fi

# Test root user rejection
kubectl apply -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: root-user-test
  namespace: applications
spec:
  containers:
  - name: test
    image: nginx
    securityContext:
      runAsUser: 0
EOF

if kubectl get pod root-user-test -n applications 2>/dev/null; then
  echo "FAIL: Root user pod was not rejected"
else
  echo "PASS: Root user pod was correctly rejected"
fi

# 2. Test OPA Gatekeeper Policies
echo "=== Testing OPA Gatekeeper Policies ==="

# Test required labels policy
kubectl apply -f - <<EOF
apiVersion: apps/v1
kind: Deployment
metadata:
  name: no-labels-test
  namespace: applications
spec:
  replicas: 1
  selector:
    matchLabels:
      app: test
  template:
    metadata:
      labels:
        app: test
    spec:
      containers:
      - name: test
        image: nginx
EOF

if kubectl get deployment no-labels-test -n applications 2>/dev/null; then
  echo "FAIL: Deployment without required labels was not rejected"
else
  echo "PASS: Deployment without required labels was correctly rejected"
fi

# 3. Test Network Policies
echo "=== Testing Network Policies ==="

# Create test pods
kubectl run network-test-source --image=busybox --rm -it --restart=Never -n applications -- sleep 3600 &
kubectl run network-test-target --image=nginx -n applications

# Test network connectivity (should be blocked by default deny policy)
kubectl exec network-test-source -n applications -- wget -qO- --timeout=5 network-test-target.applications.svc.cluster.local
if [ $? -eq 0 ]; then
  echo "FAIL: Network policy did not block unauthorized traffic"
else
  echo "PASS: Network policy correctly blocked unauthorized traffic"
fi

# 4. Test RBAC
echo "=== Testing RBAC ==="

# Test unauthorized namespace access
kubectl auth can-i get pods --namespace=kube-system --as=system:serviceaccount:applications:default
if [ $? -eq 0 ]; then
  echo "FAIL: Unauthorized access to kube-system namespace"
else
  echo "PASS: RBAC correctly blocked unauthorized namespace access"
fi

# 5. Test Workload Identity
echo "=== Testing Workload Identity ==="

# Create test pod with workload identity
kubectl apply -f - <<EOF
apiVersion: v1
kind: Pod
metadata:
  name: workload-identity-test
  namespace: applications
  labels:
    azure.workload.identity/use: "true"
spec:
  serviceAccountName: workload-identity-test-sa
  containers:
  - name: test
    image: mcr.microsoft.com/azure-cli:latest
    command: ["/bin/bash", "-c", "az account show && sleep 300"]
EOF

# Verify workload identity authentication
kubectl logs workload-identity-test -n applications | grep -q "subscription"
if [ $? -eq 0 ]; then
  echo "PASS: Workload identity authentication successful"
else
  echo "FAIL: Workload identity authentication failed"
fi

echo "Security policy enforcement testing completed"
```

### Incident Response Testing
**Security Incident Simulation**:
```yaml
apiVersion: batch/v1
kind: Job
metadata:
  name: incident-response-simulation
  namespace: security
spec:
  template:
    spec:
      containers:
      - name: incident-simulator
        image: company/incident-simulator:latest
        command: ["/bin/bash", "-c"]
        args:
        - |
          echo "Simulating security incidents..."

          # Incident 1: Suspicious pod creation
          kubectl apply -f - <<EOF
          apiVersion: v1
          kind: Pod
          metadata:
            name: suspicious-pod
            namespace: applications
            labels:
              purpose: crypto-mining
          spec:
            containers:
            - name: miner
              image: monero-miner:latest
              resources:
                requests:
                  cpu: 2000m
                  memory: 4Gi
          EOF

          # Incident 2: Unauthorized secret access
          kubectl get secrets --all-namespaces > /tmp/secret-dump.txt

          # Incident 3: Network reconnaissance
          nmap -sS 10.240.0.0/24 > /tmp/network-scan.txt

          # Incident 4: Privilege escalation attempt
          kubectl create clusterrolebinding test-admin --clusterrole=cluster-admin --serviceaccount=applications:default

          echo "Incident simulation completed"

          # Wait for incident response
          sleep 600
        securityContext:
          runAsNonRoot: true
          runAsUser: 1000
      restartPolicy: Never
```

### Security Dashboard and Reporting
**Security Posture Dashboard**:
```json
{
  "dashboard": {
    "title": "Development Environment Security Posture",
    "tags": ["security", "development"],
    "panels": [
      {
        "title": "Security Scan Results",
        "type": "table",
        "targets": [
          {
            "expr": "security_scan_vulnerabilities_total",
            "format": "table"
          }
        ]
      },
      {
        "title": "Policy Violations",
        "type": "graph",
        "targets": [
          {
            "expr": "sum(increase(gatekeeper_violations_total[1h])) by (violation_kind)",
            "legendFormat": "{{violation_kind}}"
          }
        ]
      },
      {
        "title": "Security Events",
        "type": "graph",
        "targets": [
          {
            "expr": "sum(increase(kubernetes_audit_total{verb=~\"create|update|delete\"}[5m])) by (verb)",
            "legendFormat": "{{verb}}"
          }
        ]
      },
      {
        "title": "Compliance Score",
        "type": "gauge",
        "targets": [
          {
            "expr": "security_compliance_score_percentage",
            "legendFormat": "Compliance %"
          }
        ]
      }
    ]
  }
}
```

## Testing

### Security Validation Testing
- Comprehensive vulnerability assessment execution
- Penetration testing scenario validation
- Security policy enforcement verification
- Compliance control implementation testing

### Incident Response Testing
- Security incident simulation and detection
- Incident response procedure validation
- Forensic investigation capability testing
- Recovery and remediation process verification

### Continuous Security Testing
- Automated security scanning integration
- Security monitoring and alerting validation
- Security policy compliance verification
- Security metrics and reporting accuracy

## Change Log
| Date | Version | Description | Author |
|------|---------|-------------|--------|
| 2025-01-19 | 1.0 | Initial story creation | Scrum Master |

## Dev Agent Record
*This section will be populated by the development agent during implementation*

## QA Results
*This section will be populated by the QA agent after story completion*